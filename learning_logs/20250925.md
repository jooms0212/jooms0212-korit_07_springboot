3. 자격 증명을 저장하는 새 클래스를 추가할겁니다. Record 개념을 사용할 예정. domain 패키지 내에 AccountCredentials 레코드를 생성하겠습니다.

  - Record 데이터만 보관하는 클래스가 필요할 때 많은 상용구 코드를 피할 수 있는 방식으로,
```java
package com.example.cardatabase.domain;

public record AccountCredentials(String username, String password) { }
```
  - 이상과 같이 작성했을 경우 username / password에 대한 Getter / Setter 안써도 됩니다.
 
# Java Record
- Record는 데이터 운반체(Data Carrier) 역할을 하는 클래스를 간결하게 생성하기 위해 14에서 도입되었고, 16에서 정식 기능이 됐습니다.
주로 DTO(Data Transfer Object)나 POJO(Plain Old Java Object)와 같은 불변 데이터 객체를 만들 때 발생하는 반복적인 상용구 코드(boilerplate code) 작성을 줄이는 것을 목적으로 발명됨.

## Record 특징
1. 간결성
  - field만을 정의하면, 컴파일러가 필요한 메서드들을 자동으로 생성합니다.
  - 이상의 경우는 username과 password에 대한 getter / setter를 자동으로 생성한다고 했습니다.
2. 불변성
  - 모든 field는 private final로 선언됩니다. -> private이니까 getter / setter로 경유하여 값을 넣어야겠네요.
3. 자동생성
  - 이하의 멤버들이 자동으로 생성됩니다.
    1. AllArgsConstructor - () 내에 정의된 모든 field들을 사용하는 생성자를 자동으로 만들어줍니다.
    2. 접근자 메서드(Accessor Methods) : 전통적으로 특정 field에 접근하기 위한 접두사인 `get`을 사용하지 않고 field명을 그대로 씁니다. person.getName()과 같이 사용하는게 아니라 person.name()
4. 제약사항
  - 다른 클래스를 상속 받을 수 없음.
  - 다른 인스턴스 field를 선언할 수 없으며, 레코드 header에 정의된 field들 외의field는 static이어야만 함.
```java
public record Person(String name, int age) {
    // getter / setter는 알아서 만들어지기 때문에 Lombok 도입 등이 불필요
    // 객체 생성 시의 유효성 검사를 위하여 생성자를 커스텀 할 수 있습니다.
    public Person {
        if (age < 0) {
          throw new IllegalArgumentException("불가능한 나이 입력입니다.");
        }
    }
}

public class PersonMain {
   public static void main(String[] args) {
    // Record를 통한 객체 생성 및 사용 방법 예시들을 작성합니다.
    Person person1 = new Person("김일", 21); // AllArgsConstructor가 기본생성이기 때문에 얘로만 객체 생성 가능
    String name = person1.name();
    System.out.printlin(name + " 학생은 " + person1.age() + " 살입니다.");
    System.out.printlin(person1.toString());  // 원래 toString()은 직접 호출하지 않고 객체명만으로 뽑아낼 수 있었지만 뭐 이런식으로 사용합니다. Person[name=김일, age=21]
  }
}
```
# Java Optional
`java.util.Optional<T>` 클래스는 Java 8에서 도입되었고, _값이 있을 수도 있고, 없을 수도 있는(present or absent)_ 컨테이너 객체. 주요 목적은 null 값을 직접 처리하지 못하도록 하여, 프로그래머의 실수를 줄이고 흔히 발생하는 `NullPointerException`예외를 방지하는 것입니다.

## Optional 특징
1. NPE 방지
  - 메서드의 return 값이 null이 될 가능성이 있을 때(findByUsername(username)의 결과값이 null일 수 있는 것처럼), Optional을 도입하면 호출자는 명시적으로 값이 없을 때의 상황을 처리하도록 강제됩니다(빼먹고 지나갈 수 없으니까 오류 발생 안하겠죠).
2. 함수형 스타일
  - map(), filter(), ifPresent() 등의 메서드를 제공하고 함수형 프로그래밍 스타일로 코드를 작성할 수 있습니다.
3. 의도 노출
  - Optional을 도입한다는 것만으로도 특정 메서드의 return값이 null이 될 수 있음을 다른 개발자들이 쉽게 알 수 있습니다.

### Optional 객체 생성 및 사용 방법
1. Optional.of(T value)
  - null이 아닌 값으로 Optional을 생성. 만약 이 메서드의 호출로 value에 null 넣으면 NullPointerException 발생함.
2. Optional.ofNullable(T value)
  - value가 null일 수도 있는 값으로 Optional 생성. null이면 Optional.empty()를 return
3. Optional.empty()
  - 값이 없는 비어있는 Optional 객체를 return.

### 데이터 처리 메서드(NPE 방지 및 대체)
1. isPresent()
  - 값이 존재하면 true 반환
2. get()
  - 값을 반환. 값이 없으면 NoSuchElementException을 발생시키므로, isPresent()로 확인 후 사용하거나 다른 메서드를 사용하는 것이 좋습니다.
  - 저희 수업 상황에서의 예시
```java
@Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<AppUser> user = userRepository.findByUsername(username);

        UserBuilder builder = null;
        if (user.isPresent()) { // 이하의 실행문이 실행된다면 user에 AppUser 객체가 있다는 의미   // 이 부분에서 Optional의 메서드를 사용했습니다.
            AppUser currentUser = user.get();                                                 // 여기서도 썼죠. 각각 1, 2번 메서드를 사용함.
            builder = User.withUsername(username);
            builder.password(currentUser.getPassword());
            builder.roles(currentUser.getRole());
        } else {
            throw new UsernameNotFoundException("User not found.");
        }

        return builder.build();
    }
```
3. orElse(T other)
  - 값이 존재하면 그 값을 반환하고, 값이 없으면 `other`로 전달된 기본 값을 return
4. orElseGet(Supplier<? extends T> other)
  - 값이 존재하면 그 값을 반환하고, 값이 없으면 `other`(람다식)의 결과를 반환(orElse와 달리 값이 없는 경우에만 람다식이 호출됨).
5. ifPresent(Consumer<? super T> action)
  - 값이 존재하는 경우에만 `action`(람다식)을 실행

## Optional 사용 예시
```java
public class Example1 {
  public static void main(String[] args) {
    Optional<String> maybeName = Optional.ofNullable(findByUsername(username)); // 값이 null일 수도 있음

    // 1. 값이 있을 때만 작업 수행하는 .ifPresent() - 람다식 적용
    maybeName.ifPresent(name -> System.out.println("사용자 이름 : " + name));

    // 2. 값이 없을 때 기본 값 제공
    String name = maybeName.orElse("Guest");    // 값이 없으면 "Guest"를 return
    System.out.printlin("사용자 이름 : " + name); // 사용자 이름 : Guest 가 결과값이겠네요.

    // 3. 값이 없을 때의 예외 발생
    String requriedName = maybeName.orElseThrow();  // 값이 없으면 NoSuchElementException 발생
  }
}
```

# 로그인을 위한 AccountCredentials를 Record로 생성했습니다 이후 과정.
1. 로그인을 위한 controller 클래스 생성 할겁니다.`/login`엔드 포인트를 POST 메서드로 호출하고 사용자 이름과 암호를 요청 본문과 함께 전송하여 로그인할겁니다(그러니까 Spring Security의 default를 사용하지 않겠다는 의미가 되겠네요).
   - web 패키지 내에 LoginController 클래스 생성.
   - 로그인 성공 시에 JWT를 생성하는 데 이용될 JwtService 인스턴스를 컨트롤러 클래스에 삽입해야 합니다. 이하는 그 과정을
   풀어낸 코드입니다.
```java
package com.example.cardatabase.web;

import com.example.cardatabase.domain.AccountCredentials;
import com.example.cardatabase.service.JwtService;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LoginController {
    // field 선언 -> final 키워드
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;

    // 그렇기 때문에 필수적으로 AllArgsContructor로 생성해야만 하고
    public LoginController(JwtService jwtService, AuthenticationManager authenticationManager) {
        this.jwtService = jwtService;
        this.authenticationManager = authenticationManager;
    }

    // Post 요청을 위한 method를 작성 중인데
    // 저희가 field로 받아온 부분을 사용하여 method 호출을 이 LoginController의 getToken()메서드 내에서 하겠죠.
    @PostMapping("/login")
    public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {
        // 여기에 토큰 생성하고 응답의 Authorization 헤더로 전송해주는 로직 작성할겁니다.
    }
}
```